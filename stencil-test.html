<!DOCTYPE html>
<html>
<head>
  <title>Stencil Viewport Test v3</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 4px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="info">
    Stencil Viewport Test v3<br>
    Space: cycle view mode<br>
    M: toggle mask visibility<br>
    <span id="status">Loading...</span>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // === GLOBALS ===
    let renderer, scene, cameraA, cameraB;
    let maskScene, maskCamera;
    let maskMeshA, maskMeshB;
    let borderScene, borderLine;
    
    let viewMode = 0;
    let showMasks = false;

    function init() {
      // Create renderer with stencil buffer
      renderer = new THREE.WebGLRenderer({
        antialias: false,
        stencil: true
      });
      renderer.autoClear = false;
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Verify stencil buffer
      const gl = renderer.getContext();
      const stencilBits = gl.getParameter(gl.STENCIL_BITS);
      document.getElementById('status').textContent = 'Stencil bits: ' + stencilBits;
      console.log('Stencil bits:', stencilBits);

      // Create main scene
      scene = new THREE.Scene();
      scene.background = null; // No auto background - we control clearing

      // Ground plane
      const groundGeo = new THREE.PlaneGeometry(20, 20, 20, 20);
      const groundMat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: true });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Red cube
      const redCube = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 1.5, 1.5),
        new THREE.MeshBasicMaterial({ color: 0xff4444 })
      );
      redCube.position.set(-2, 1, 0);
      scene.add(redCube);

      // Blue cube
      const blueCube = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 1.5, 1.5),
        new THREE.MeshBasicMaterial({ color: 0x4444ff })
      );
      blueCube.position.set(2, 1, 0);
      scene.add(blueCube);

      // Green cube
      const greenCube = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 1.5, 1.5),
        new THREE.MeshBasicMaterial({ color: 0x44ff44 })
      );
      greenCube.position.set(0, 1, -3);
      scene.add(greenCube);

      // Camera A: front view
      cameraA = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      cameraA.position.set(0, 5, 10);
      cameraA.lookAt(0, 0, 0);

      // Camera B: side view
      cameraB = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      cameraB.position.set(10, 5, 0);
      cameraB.lookAt(0, 0, 0);

      // Mask scene and camera (NDC coordinates)
      maskScene = new THREE.Scene();
      maskCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      // Mask A: top-left triangle (will use stencil ref = 1)
      maskMeshA = createMaskMesh([
        [-1, 1],
        [1, 1],
        [-1, -1]
      ], 0xff0000);

      // Mask B: bottom-right triangle (will use stencil ref = 2)
      maskMeshB = createMaskMesh([
        [1, 1],
        [1, -1],
        [-1, -1]
      ], 0x0000ff);

      // Border line
      borderScene = new THREE.Scene();
      const borderGeo = new THREE.BufferGeometry();
      borderGeo.setAttribute('position', new THREE.Float32BufferAttribute([
        -1, -1, 0,
        1, 1, 0
      ], 3));
      borderLine = new THREE.Line(borderGeo, new THREE.LineBasicMaterial({ color: 0xffffff }));
      borderScene.add(borderLine);

      window.addEventListener('resize', onResize);
      window.addEventListener('keydown', onKeyDown);

      animate();
    }

    function createMaskMesh(vertices, debugColor) {
      const positions = [];
      for (let i = 1; i < vertices.length - 1; i++) {
        positions.push(vertices[0][0], vertices[0][1], 0);
        positions.push(vertices[i][0], vertices[i][1], 0);
        positions.push(vertices[i + 1][0], vertices[i + 1][1], 0);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

      const material = new THREE.MeshBasicMaterial({
        color: debugColor,
        side: THREE.DoubleSide,
        colorWrite: false,
        depthWrite: false,
        depthTest: false
      });

      return new THREE.Mesh(geometry, material);
    }

    /**
     * Write a mask to the stencil buffer with a specific reference value
     */
    function writeMask(maskMesh, refValue) {
      const gl = renderer.getContext();
      
      // Configure stencil to write refValue wherever the mask renders
      gl.enable(gl.STENCIL_TEST);
      gl.stencilFunc(gl.ALWAYS, refValue, 0xFF);
      gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
      gl.stencilMask(0xFF);
      
      // Render mask
      maskScene.add(maskMesh);
      renderer.render(maskScene, maskCamera);
      maskScene.remove(maskMesh);
      
      gl.disable(gl.STENCIL_TEST);
    }

    /**
     * Render scene where stencil equals refValue
     */
    function renderWithStencil(sceneToRender, camera, refValue) {
      const gl = renderer.getContext();
      
      // Clear depth only (preserve color and stencil)
      renderer.clearDepth();
      
      // Configure stencil test: only render where stencil == refValue
      gl.enable(gl.STENCIL_TEST);
      gl.stencilFunc(gl.EQUAL, refValue, 0xFF);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      gl.stencilMask(0x00); // Don't modify stencil during scene render
      
      // Render scene
      renderer.render(sceneToRender, camera);
      
      gl.disable(gl.STENCIL_TEST);
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now() * 0.001;
      scene.children.forEach(function(child) {
        if (child.geometry && child.geometry.type === 'BoxGeometry') {
          child.rotation.y = time * 0.5;
        }
      });

      const gl = renderer.getContext();

      if (viewMode === 0) {
        // === SPLIT SCREEN MODE ===
        
        // 1. Clear everything (color to dark, depth, stencil to 0)
        gl.clearColor(0.133, 0.133, 0.2, 1); // Match scene background
        renderer.clear(true, true, true);
        
        // 2. Write BOTH masks to stencil buffer (different ref values)
        writeMask(maskMeshA, 1);  // Top-left triangle = 1
        writeMask(maskMeshB, 2);  // Bottom-right triangle = 2
        
        // 3. Render scene for region A (where stencil == 1)
        renderWithStencil(scene, cameraA, 1);
        
        // 4. Render scene for region B (where stencil == 2)
        renderWithStencil(scene, cameraB, 2);
        
        // 5. Draw border on top (no stencil test)
        renderer.render(borderScene, maskCamera);

      } else if (viewMode === 1) {
        gl.clearColor(0.133, 0.133, 0.2, 1);
        renderer.clear(true, true, true);
        renderer.render(scene, cameraA);
      } else {
        gl.clearColor(0.133, 0.133, 0.2, 1);
        renderer.clear(true, true, true);
        renderer.render(scene, cameraB);
      }
    }

    function onResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      cameraA.aspect = window.innerWidth / window.innerHeight;
      cameraA.updateProjectionMatrix();
      cameraB.aspect = window.innerWidth / window.innerHeight;
      cameraB.updateProjectionMatrix();
    }

    function onKeyDown(e) {
      if (e.code === 'Space') {
        e.preventDefault();
        viewMode = (viewMode + 1) % 3;
        var modeNames = ['Split Screen', 'Camera A Only', 'Camera B Only'];
        document.getElementById('status').textContent = 'Mode: ' + modeNames[viewMode];
      }
      if (e.code === 'KeyM') {
        showMasks = !showMasks;
        maskMeshA.material.colorWrite = showMasks;
        maskMeshB.material.colorWrite = showMasks;
      }
    }

    init();
  </script>
</body>
</html>
